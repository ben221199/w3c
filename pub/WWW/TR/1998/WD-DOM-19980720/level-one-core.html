<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- Generated: Sun Jul 19 19:48:49 PDT 1998 -->
<html lang='en'>
<head>
  <title> Document Object Model (Core) Level 1</title>
  <link rel='stylesheet' type='text/css' href='./dom.css'>
</head>
<body>
<div class='noprint'>
<hr>
<table width='100%' cellpadding='0' class='navigation-bar'>
<tr>
<td width='30%' align='left'><a href='introduction.html'><img border='0' src='./back.jpg' alt=' What is the Document Object Model?'></a></td>
<td width='30%' align='center'><a href='cover.html'><img border='0' src='./up.jpg' alt='Cover'></a></td>
<td width='30%' align='right'><a href='level-one-html.html'><img border='0' src='./forward.jpg' alt=' Document Object Model (HTML) Level 1'></a></td>
</tr>
</table>
<hr>
</div>

<a name='ID-419945773'></a>
<h1 class='div1'>1. Document Object Model (Core) Level 1</h1><dl>
<dt><i>Editors</i></dt>
<dd>Mike Champion, ArborText (from November 20, 1997)</dd><dd>Steve Byrne, JavaSoft (until November 19, 1997)</dd><dd>Gavin Nicol, Inso EPS</dd></dl>

<!--NewPage--><!-- this is for html2ps -->

<a name='ID-1590626201'></a>
<h2 class='div2'>1.1. Introduction</h2><p>This specification defines a minimal set of objects and
      interfaces for accessing and manipulating document objects.
      The functionality specified in this draft (the
      <em>core</em> functionality) should be
      sufficient to implement higher level operations, such as
      navigating and modifying a document.
      <p>Level 1 of the Document Object Model (DOM) provides a common
      API for software developers and web script authors to access and
      manipulate parsed HTML and XML content inside conforming
      products. Primary document structures and some document type
      declarations are made available. Level 1 also allows creation
      from scratch of entire web documents in memory;
      saving those documents persistently is left to the programmer.
      DOM Level 1 is intentionally limited in scope to methods to
      represent and manipulate document structure and content; a
      standard API for controlling how documents are rendered via
      stylesheets, validated against a DTD, accessed by given users,
      etc., will be  specified in a subsequent revision level of the
      DOM. <br>
<a name='ID-BBACDC08'></a>
<h2 class='div2'>1.2. Fundamental Interfaces</h2><p>The interfaces within this section are considered
      <em>fundamental</em>, and must be fully implemented by all
      conformant implementations of the DOM, including all HTML DOM
      implementations.</p><a name='ID-258A00AF'></a>
<h4>Enumeration <code><i>ExceptionCode</i></code></h4>
<blockquote>
<p>An integer indicating the type of error generated.<br>
<table width='80%' cellpadding=5 border=0>
<tr><td bgcolor='#cfcfcf' colspan=2>
<b>Enumerator Values</b></td></tr></table>
<table width='80%' border='1' cellpadding='5'>
<tr><td width='30%'>UNSUPPORTED_DOCUMENT_ERR</td><td><p>If the implementation does not support the type of document requested</td></tr>
<tr><td width='30%'>NOT_CHILD_ERR</td><td><p>If specified node is not a child of this node</td></tr>
<tr><td width='30%'>NO_CHILDREN_ALLOWED_ERR</td><td><p>If this node is of a type that does not allow children of the 
	type of node specified.</td></tr>
<tr><td width='30%'>INDEX_SIZE_ERR</td><td><p>If index is negative, or greater than or equal to the 
        number of nodes in the list</td></tr>
<tr><td width='30%'>WSTRING_SIZE_ERR</td><td><p>If the specfied range of text will not fit into a wstring</td></tr>
<tr><td width='30%'>DATA_SIZE_ERR</td><td><p>If the specfied offset is greater than the number of 
	characters in data</td></tr>
</table>
</blockquote>
<dl>
<dt><b>Exception <i><a name='ID-17189187'>DOMException</a></i></b></dt>
<dd>
<p>DOM operations only raise exceptions in "exceptional"
      circumstances, i.e., when an operation is impossible
      to perform (either for logical reasons, because data is lost, or 
      because the implementation has become unstable).  In general, DOM methods
      return specific error values in ordinary
      processing situation, such as out-of-bound errors when using
      <code>NodeList</code>. 
    
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
exception DOMException {
   ExceptionCode   code;
};

</pre>
</dd>
</dl>
</dd>
</dl>

<dl>
<dt><b>Interface <i><a name='ID-102161490'>DOMImplementation</a></i></b></dt>
<dd>
<p>The <code>DOMImplementation</code> interface provides a
      number of methods for performing operations that are independent
      of any particular instance of the document object model. <i><b>Note: </b>The DOM Level 1 does not specify a way of creating a
      document instance, and hence document creation is an operation
      specific to an implementation. Future Levels of the DOM specification
      will provide methods for creating documents directly.</i><br>
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface DOMImplementation {
  boolean                   hasFeature(in wstring feature, 
                                       in wstring version);
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Methods</b></dt>
<dd>

<dl>
<dt><code class='method-name'><b><i><a name='ID-5CED94D7'></a><a name='method-hasFeature'>hasFeature</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Test if the DOM implementation implements a
	   specific feature.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>feature</b><td><td>
<p>The package name of the feature to
	    test. In Level 1, the legal values are "HTML" and
	"XML" (case-insensitive).</td></tr>
<tr><td valign='top'><b>version</b><td><td>
<p>This is the version number of the package name to
	    test.  If not specified, any supported version of the feature will
	cause the method to return <code>TRUE</code>.
	</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p><code>TRUE</code> if the feature is implemented in the specified
	version, <code>FALSE</code> otherwise.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>
</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-B63ED1A3'>DocumentFragment</a></i></b></dt>
<dd>
<p><code>DocumentFragment</code> is the "lightweight" or
      "minimal" document object, and it (as the superclass of
      <code>Document</code>) anchors the XML/HTML tree in a
      full-fledged document.<p>The children of a <code>DocumentFragment</code> node are zero
      or more nodes representing the tops of any sub-trees defining
      the structure of the document, including the actual root element
      of the XML or HTML document, as well as the XML prolog,
      comments, processing instructions, etc. For a document fragment,
      there could be a number of  subtrees, since fragments do not
      need to be well-formed XML documents (although they do need to
      follow the rules imposed upon well-formed XML parsed entities,
      which can have multiple top nodes). Criteria for
      "well-formedness" are  much looser in the HTML world, and the
      DOM will not attempt to impose any constraints here. For a
      complete HTML document, this will contain an
      <code>Element</code> instance whose <code>tagName</code> is
      <code>"HTML"</code>; for a complete XML document this
      will contain the outermost element, i.e. the
      <i>element</i> non-terminal in production
      <em>[41]</em> in <a href='http://www.w3.org/TR/PR-xml.html#sec3'>Section 3</a>

      of the XML-lang specification. <p>DocumentFragments have two primary uses: First of all, a
      Document IS A DocumentFragment so that a Document really is a
      tree, and not a forest or grove, with all Nodes having a common
      ancestor, namely the Document Node itself.  For example, a
      document which started with a comment followed by an HTML
      element would result in the Document node having two children
      each with the Document node as parent.<p>Second of all, it is very common to want to be able to extract
      a portion of a document's tree or to create a new fragment of a
      document. Imagine implementing a user command like cut or
      rearranging a document by moving fragments around. It is
      desirable to have an object which can hold such fragments and it
      is quite natural to use a Node for this purpose. While it is
      true that a Document itself could fulfill this role, a Document
      object can potentially be quite heavyweight when what is really
      needed is a very lightweight object. DocumentFragment is such an
      object and it contains a reference to a Document so that the
      Document interface is indirectly available for those times when
      it is needed.<p>Furthermore, various operations -- such as inserting Nodes as
      children of  another Node -- may take
      <code>DocumentFragment</code> objects as arguments;  this will
      result in all the child nodes of the DocumentFragment being
      moved to the child list of this node.<p>Note that a DocumentFragment must always contain a valid
      reference to a Document object. If the DocumentFragment *is* a
      Document, the reference is to itself. A DocumentFragment can
      contain the same Node types as a Document. However, there is no
      requirement that a DocumentFragment be a well-formed document.
      For example, a DocumentFragment might have only one child and
      that child node could be a TextNode. Such a structure model represents
      neither an HTML document nor a well-formed XML document. The
      nature of the DOM's structure model  representation means that a
      DocumentFragment will follow the rules imposed upon a
      well-formed  XML parsed entity. <font color='red'>(<i><b>ED: </b>The exact relationship between Entity,
	DocumentFragment and Document is still subject to
	change.)</i></font><br>

<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface DocumentFragment : Node {
  readonly attribute  Document             masterDoc;
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Attributes</b></dt>
<dd>

<dl>
<dt><code class='attribute-name'><b><i><a name='ID-8D898481'></a><a name='attribute-masterDoc'>masterDoc</a></i></b></code></dt>
<dd>
<p>This provides access to the <code>Document</code> object
	associated with this <code>DocumentFragment</code>. </dd>
</dl>

</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-1491798679'>Document</a></i></b></dt>
<dd>
<p>The <code>Document</code> interface represents the entire
      HTML or XML document. Conceptually, it is the root of the
      document tree, and provides the  primary access to the
      document's data. A document <em>ISA</em> document fragment
      that happens to be a discrete unit in the repository, and has
      contextual information similar to a document transported over
      HTTP. Since <code>Document</code> inherits from
      <code>DocumentFragment</code>, its children are contents of the
      <code>Document</code>,  e.g., the root <code>Element</code>, the
      XML prolog, any processing instructions and or comments, etc.
    <p>Since elements, text nodes, comments, processing instructions,
      etc. cannot exist outside the context of a
      <code>Document</code>, the <code>Document</code> interface also
      contains the factory methods needed to create these objects. 
    
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface Document : DocumentFragment {
  readonly attribute  DocumentType         doctype;
  readonly attribute  DOMImplementation    implementation;
  readonly attribute  Element              documentElement;
  Element                   createElement(in wstring tagName);
  DocumentFragment          createDocumentFragment();
  Text                      createTextNode(in wstring data);
  Comment                   createComment(in wstring data);
  CDATASection              createCDATASection(in wstring data);
  ProcessingInstruction     createProcessingInstruction(in wstring target, 
                                                        in wstring data);
  Attribute                 createAttribute(in wstring name);
  Entity                    createEntity();
  EntityReference           createEntityReference();
  NodeList                  getElementsByTagName(in wstring tagname);
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Attributes</b></dt>
<dd>

<dl>
<dt><code class='attribute-name'><b><i><a name='ID-B63ED1A31'></a><a name='attribute-doctype'>doctype</a></i></b></code></dt>
<dd>
<p>For XML, this provides access to the Document Type
	Definition (see DocumentType) associated with
	this XML document. For HTML documents and XML documents
	without a document type definition this returns
	<code>null</code>.</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-1B793EBA'></a><a name='attribute-implementation'>implementation</a></i></b></code></dt>
<dd>
<p>This provides access to the DOMImplementation object
	that handles this document.  This is necessary because a DOM
	application may use objects from multiple implementations, and
	it may be necessary to get a specific document's
	<code>DOMImplementation </code> in order to query the features
	it supports. 
      </dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-87CD092'></a><a name='attribute-documentElement'>documentElement</a></i></b></code></dt>
<dd>
<p>This is a convenience attribute to that allows direct
	access to the child node that is the root element of  the
	document. For HTML documents, this is the element with
	the tagName "HTML". </dd>
</dl>

</dd>
</dl>

<dl>
<dt><b>Methods</b></dt>
<dd>

<dl>
<dt><code class='method-name'><b><i><a name='ID-2141741547'></a><a name='method-createElement'>createElement</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Create an element of the type specified. Note that the
	instance returned will implement the Element interface, so
	attributes can be specified directly  on the returned
	object.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>tagName</b><td><td>
<p>The name of the element type to
	    instantiate.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>A new <code>Element</code> object.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-35CB04B5'></a><a name='method-createDocumentFragment'>createDocumentFragment</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Create an empty <code>DocumentFragment</code> object.
	The masterDoc for this newly created DocumentFragment is the
	Document  on which this method is invoked.
      
<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>A new <code>DocumentFragment</code>.</dd>
</dl>
<br>
This method has no parameters.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-1975348127'></a><a name='method-createTextNode'>createTextNode</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Create a <code>Text</code> node given the specified
	string.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>data</b><td><td>
<p>The data for the node.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The new <code>Text</code> object.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-1334481328'></a><a name='method-createComment'>createComment</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Create a <code>Comment</code> node given the specified
	string.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>data</b><td><td>
<p>The data for the node.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The new <code>Comment</code> object.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-D26C0AF8'></a><a name='method-createCDATASection'>createCDATASection</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Create a <code>CDATASection</code> node whose value  is
	the specified string.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>data</b><td><td>
<p>The data for the CDATASection contents.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The new <code>CDATASection</code> object.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-135944439'></a><a name='method-createProcessingInstruction'>createProcessingInstruction</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Create a <code>ProcessingInstruction</code> node given
	the specified name and data strings.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>target</b><td><td>
<p>The target part of the processing instruction.</td></tr>
<tr><td valign='top'><b>data</b><td><td>
<p>The data for the node.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The new <code>ProcessingInstruction</code> object.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-1084891198'></a><a name='method-createAttribute'>createAttribute</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Create an <code>Attribute</code> of the given name.
	Note that the <code>Attribute</code> instance
	can then be set on an <code>Element</code> using the
	<code>setAttribute</code> method.
      
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>name</b><td><td>
<p>The name of the attribute.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>A new <code>Attribute</code> object.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-8B495591'></a><a name='method-createEntity'>createEntity</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Creates an Entity object.
<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The new <code>Entity</code> object.</dd>
</dl>
<br>
This method has no parameters.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-392B75AE'></a><a name='method-createEntityReference'>createEntityReference</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Creates an EntityReference object.
<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The new <code>EntityReference</code> object.</dd>
</dl>
<br>
This method has no parameters.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-A6C9094'></a><a name='method-getElementsByTagName'>getElementsByTagName</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Returns a collection of all descendant <code>Elements</code> with
	a given tag name.  
      
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>tagname</b><td><td>
<p>The name of the tag to match on.  If the string
	    "*" is given, this method will return all elements in the document</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>A new <code>NodeList</code> object containing
	  reference to all the <code>Elements</code>
	  found.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>
</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-1950641247'>Node</a></i></b></dt>
<dd>
<p>The Node object is the primary datatype for the entire
      Document Object Model. It represents a single node in the
      document tree. While all objects implementing the
      <code>Node</code> interface expose methods for dealing with
      children, not all objects implementing the <code>Node</code>
      interface may have children. For example, <code>Text</code>
      nodes may not have children, and adding children to such nodes
      will result in an error. 
      <p>The attributes nodeName, nodeValue and attributes are 
	included as a mechanism to get at node information without 
	casting down to the specific derived interface. In cases where 
	there is no obvious mapping of these attributes for a
	specific nodeType (e.g. nodeValue for an Element or attributes 
	for a Comment), the value returned is null. Note that the 
	specialized interfaces may contain
	additional and more convenient mechanism to get and set the relevant
	information.
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface Node {
  // NodeType
  const unsigned short      DOCUMENT           = 1;
  const unsigned short      ELEMENT            = 2;
  const unsigned short      ATTRIBUTE          = 3;
  const unsigned short      PROCESSING_INSTRUCTION = 4;
  const unsigned short      COMMENT            = 5;
  const unsigned short      TEXT               = 6;
  const unsigned short      CDATA_SECTION      = 7;
  const unsigned short      DOCUMENT_FRAGMENT  = 8;
  const unsigned short      ENTITY             = 9;
  const unsigned short      ENTITY_REFERENCE   = 10;
  const unsigned short      DOCUMENT_TYPE      = 11;

  readonly attribute  wstring              nodeName;
           attribute  wstring              nodeValue;
  readonly attribute  unsigned short       nodeType;
  readonly attribute  Node                 parentNode;
  readonly attribute  NodeList             childNodes;
  readonly attribute  Node                 firstChild;
  readonly attribute  Node                 lastChild;
  readonly attribute  Node                 previousSibling;
  readonly attribute  Node                 nextSibling;
  readonly attribute  NamedNodeMap         attributes;
  Node                      insertBefore(in Node newChild, 
                                         in Node refChild)
                                         raises(DOMException);
  Node                      replaceChild(in Node newChild, 
                                         in Node oldChild)
                                         raises(DOMException);
  Node                      removeChild(in Node oldChild)
                                        raises(DOMException);
  Node                      appendChild(in Node newChild);
  boolean                   hasChildNodes();
  Node                      cloneNode(in boolean deep);
  boolean                   equals(in Node arg, 
                                   in boolean deep);
};

</pre>
</dd>
</dl>
<a name='ID-1841493061'></a>
<h4>Definition group <code><i>NodeType</i></code></h4>
<blockquote>
<p>An integer indicating which type of node this is.<dl>
<dt><b>Defined Constants</b></dt>
<dd><table border='0'>
<tr><td><b>DOCUMENT</b></td><td>
<p>The node is a <code>Document</code>.</td></tr>
<tr><td><b>ELEMENT</b></td><td>
<p>The node is an <code>Element</code>.</td></tr>
<tr><td><b>ATTRIBUTE</b></td><td>
<p>The node is an <code>Attribute</code>.</td></tr>
<tr><td><b>PROCESSING_INSTRUCTION</b></td><td>
<p>The node is a <code>ProcessingInstruction</code>.</td></tr>
<tr><td><b>COMMENT</b></td><td>
<p>The node is a <code>Comment</code>.</td></tr>
<tr><td><b>TEXT</b></td><td>
<p>The node is a <code>Text</code>.</td></tr>
<tr><td><b>CDATA_SECTION</b></td><td>
<p>The node is a <code>CDATASection</code>.</td></tr>
<tr><td><b>DOCUMENT_FRAGMENT</b></td><td>
<p>The node is a <code>DocumentFragment</code>.</td></tr>
<tr><td><b>ENTITY</b></td><td>
<p>The node is an <code>Entity</code>.</td></tr>
<tr><td><b>ENTITY_REFERENCE</b></td><td>
<p>The node is an <code>EntityReference</code>.</td></tr>
<tr><td><b>DOCUMENT_TYPE</b></td><td>
<p>The node is a <code>DocumentType</code>.</td></tr>
</table>
</dd></dl>
</blockquote>
<font color='red'>(<i><b>ED: </b>Should maybe change the order of Nodes to make it more logical.)</i></font><br>
<p>The values of <code>nodeName</code>, <code>nodeValue</code>,
    and <code>attributes</code> vary according to the node type as follows:
    <blockquote>
<table width='90%' border='1' cellpadding='0'><tr><td bgcolor='#cfcfcf'><b></b></td><td bgcolor='#cfcfcf'><b>nodeName</b></td><td bgcolor='#cfcfcf'><b>nodeValue</b></td><td bgcolor='#cfcfcf'><b>attributes</b></td></tr>
<tr><td valign='top'>Document</td><td valign='top'>#document</td><td valign='top'>null</td><td valign='top'>null</td></tr>
<tr><td valign='top'>Element</td><td valign='top'>tag</td><td valign='top'>null</td><td valign='top'>nodelist</td></tr>
<tr><td valign='top'>Attribute</td><td valign='top'>name</td><td valign='top'>value</td><td valign='top'>null</td></tr>
<tr><td valign='top'>ProcessingInstruction</td><td valign='top'>#processing-instruction</td><td valign='top'>text</td><td valign='top'>null</td></tr>
<tr><td valign='top'>Comment</td><td valign='top'>#comment</td><td valign='top'>comment text</td><td valign='top'>null</td></tr>
<tr><td valign='top'>Text</td><td valign='top'>#text</td><td valign='top'>the text</td><td valign='top'>null</td></tr>
<tr><td valign='top'>CDATASection</td><td valign='top'>#cdata-section</td><td valign='top'>the text</td><td valign='top'>null</td></tr>
<tr><td valign='top'>DocumentFragment</td><td valign='top'>#document-fragment</td><td valign='top'>null</td><td valign='top'>null</td></tr>
<tr><td valign='top'>Entity</td><td valign='top'>#entity</td><td valign='top'>TBD</td><td valign='top'>null</td></tr>
<tr><td valign='top'>EntityReference</td><td valign='top'>#entity-reference</td><td valign='top'>null</td><td valign='top'>null</td></tr>
<tr><td valign='top'>DocumentType</td><td valign='top'>#document-type</td><td valign='top'>TBD</td><td valign='top'>TBD</td></tr>
</table>
</blockquote>

  
<dl>
<dt><b>Attributes</b></dt>
<dd>

<dl>
<dt><code class='attribute-name'><b><i><a name='ID-F68D095'></a><a name='attribute-nodeName'>nodeName</a></i></b></code></dt>
<dd>
<p>The name of the node, or a special string for node types that
	do not have an explicit name associated with them. 
      </dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-F68D080'></a><a name='attribute-nodeValue'>nodeValue</a></i></b></code></dt>
<dd>
<p>The value of a node depends on its type; see the table above.</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-111237558'></a><a name='attribute-nodeType'>nodeType</a></i></b></code></dt>
<dd>
<p>A code representing the type of the underlying object's
	type. The actual type of the returned data is dependent on the
	language binding; the IDL specification uses an
	<code>enum</code>, and it is expected that most language
	bindings will represent this runtime-queryable node type using
	an integral data type. The names of the node type enumeration
	literals are straightforwardly derived from the names of the
	actual node subtypes, and are fully specified in the IDL
	definition of node in the <a href="level-1-bindings.html#ID-2094849111">OMG IDL Definitions for Level 1 Core</a>

      </dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-1060184317'></a><a name='attribute-parentNode'>parentNode</a></i></b></code></dt>
<dd>
<p>The parent of the given <code>Node</code> instance. All nodes,
	except Documents and DocumentFragments, have a parent. If a node has just been
	created and not yet added to the tree, it has an implicit parent which is a
	DocumentFragment. 
      <font color='red'>(<i><b>ED: </b>Attributes probably do not have a DocumentFragment as a
      parent. The parent is the Element; maybe it should not be possible to create Attributes
      outside of the context of the Element that the Attribute belongs to. )</i></font><br>
</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-1451460987'></a><a name='attribute-childNodes'>childNodes</a></i></b></code></dt>
<dd>
<p>A <code>NodeList</code> object that will enumerate all
	children of this node. If there are no children, this is a
	<code>NodeList</code> containing no nodes. The content of the
	returned <code>NodeList</code> is "live" in the
	sense that changes to the children of the node object that it
	was created from will be immediately reflected in the nodes
	returned by the <code>NodeList</code> accessors; it is not a
	static snapshot of the content of the Node. Similarly, changes
	made to the nodes returned by the <code>NodeList</code> access methods
        will be	immediately reflected in the tree.</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-169727388'></a><a name='attribute-firstChild'>firstChild</a></i></b></code></dt>
<dd>
<p>The first child of a node. If there is no such
	node, this is set to <code>null</code>.</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-61AD09FB'></a><a name='attribute-lastChild'>lastChild</a></i></b></code></dt>
<dd>
<p>The last child of a node. If there is no such
	node, this is set to <code>null</code>.</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-640FB3C8'></a><a name='attribute-previousSibling'>previousSibling</a></i></b></code></dt>
<dd>
<p>The node immediately preceding the current node in a
	breadth-first traversal of the tree. If there is no such node,
	it is set to <code>null</code>. </dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-6AC54C2F'></a><a name='attribute-nextSibling'>nextSibling</a></i></b></code></dt>
<dd>
<p>The node immediately following the current node
	in a  breadth-first traversal of the tree. If there is no such
	node, <code>null</code> is returned.
      </dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-84CF096'></a><a name='attribute-attributes'>attributes</a></i></b></code></dt>
<dd>
<p>Provides access to a <code>NamedNodeMap</code> containing the
	node's attributes (if it is an <code>Element</code>) or
	<code>null</code> otherwise. </dd>
</dl>

</dd>
</dl>

<dl>
<dt><b>Methods</b></dt>
<dd>

<dl>
<dt><code class='method-name'><b><i><a name='ID-952280727'></a><a name='method-insertBefore'>insertBefore</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Inserts a child node <code>newChild</code> before the
	existing child node <code>refChild</code>. If
	<code>refChild</code> is <code>null</code>, insert
	<code>newChild</code> at the end of the list of children. If
	<code>refChild</code> is not a child of the Node that
	<code>insertBefore</code> is being invoked on, a
	<code>DOMException</code> is raised. <p>If <code>newChild</code> is a <code>DocumentFragment</code>
        object, the entire contents of the document fragment are moved
	into the child list of this node. <i><b>Note: </b>After a successful call to this method, the <code>newChild</code>
        node will be removed from its previous position in the tree, and all
	<code>NodeList</code>s that reference the child list of this
	object, and previous and next sibling
	attributes of some children, must be updated.</i><br>
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>newChild</b><td><td>
<p>The node to insert</td></tr>
<tr><td valign='top'><b>refChild</b><td><td>
<p>The reference node, i.e., the node before which
	the new node will be inserted.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The node being inserted.</dd>
</dl>

<dl>
<dt><b>Exceptions</b></dt>
<dd>
<dl><dt><b>DOMException</b><dt><dd><p>Thrown if <code>refChild</code> is not a child
	    of this node or if this node is of a type
	that does not allow children of the type of
	the <code>newChild</code> node.</dd></dl>
</dd>
</dl>
<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-785887307'></a><a name='method-replaceChild'>replaceChild</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Replaces the child node <code>oldChild</code> with
	<code>newChild</code> in the set of children of the given
	node, and return the <code>oldChild</code> node. If
	<code>oldChild</code> was not already a child of the node that
	the <code>replaceChild</code> method is being invoked on, a
	<code>DOMException</code> is raised.
      <i><b>Note: </b>After a successful call to this method, the <code>newChild</code>
        node will be removed from its previous position in the tree and all
	  <code>NodeList</code>s that reference the child list of this
	  object, and previous and next sibling attributes of some
	  children, must be updated.</i><br>
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>newChild</b><td><td>
<p>The new node to put in the child list.</td></tr>
<tr><td valign='top'><b>oldChild</b><td><td>
<p>The node being replaced in the list.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The node replaced.</dd>
</dl>

<dl>
<dt><b>Exceptions</b></dt>
<dd>
<dl><dt><b>DOMException</b><dt><dd><p>Thrown if <code>oldChild</code> is not a child
	    of the node.</dd></dl>
</dd>
</dl>
<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-1734834066'></a><a name='method-removeChild'>removeChild</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Removes the child node indicated by
	<code>oldChild</code> from the list of children and returns
	it. If <code>oldChild</code> was not a child of the given
	node, a <code>DOMException</code> is raised.
      <i><b>Note: </b>After a successful call to this method, all
	  <code>NodeList</code>s that reference the child list of this
	  object, and previous and next sibling attributes of some
	  children, must be updated.</i><br>
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>oldChild</b><td><td>
<p>The node being removed</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The node removed.</dd>
</dl>

<dl>
<dt><b>Exceptions</b></dt>
<dd>
<dl><dt><b>DOMException</b><dt><dd><p>Thrown if <code>oldChild</code> is not a child of
	    the node.</dd></dl>
</dd>
</dl>
<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-184E7107'></a><a name='method-appendChild'>appendChild</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Adds a child node to the end of the list of children for
	this node. <i><b>Note: </b>After a successful call to this method, the <code>newChild</code>
        node will be removed from its previous position in the tree and all
	  <code>NodeList</code>s that reference the child list of this
	  object, and previous and next sibling attributes of some
	  children, must be updated.</i><br>
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>newChild</b><td><td>
<p>The node to add.<p>If it is a 
	<code>DocumentFragment</code>
        object, the entire contents of the document fragment are moved
	into the child list of this node</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The node added.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-810594187'></a><a name='method-hasChildNodes'>hasChildNodes</a></i></b></code></dt>
<dd>
<div class='method'>
<p> This is a convenience method to allow easy determination
	of whether a Node has children or not.
<dl>
<dt><b>Return Values</b></dt>
<dd>
<p> Set to <code>true</code> if the node has any children,
	<code>false</code> if the node has no children at all.</dd>
</dl>
<br>
This method has no parameters.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-3A0ED0A4'></a><a name='method-cloneNode'>cloneNode</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Returns a duplicate of a given node, i.e., serves
	as a generic "copy constructor" for Nodes. <i><b>Note: </b>Cloning a Text node will
        copy the Text Node and the text it contains; cloning an Element will
        not copy any text it contains unless it is a deep clone, since the text
        is contained in a Text node.</i><br>
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>deep</b><td><td>
<p>If TRUE, recursively clone the subtree under the
	specified node; if FALSE, clone only the node itself and
	its attributes (if it is an Element). 
	<i><b>Note: </b>When Elements are cloned, all attribute nodes
	are cloned, including those generated by the XML processor to 
	represent defaulted attributes</i><br></td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The duplicate node.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-FF6C5666'></a><a name='method-equals'>equals</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Tests whether two nodes are equivalent. <i><b>Note: </b>This method tests for equality of nodes, not
	  <em>sameness</em>  (i.e. whether the two nodes are exactly the same object)
          which should be implemented using
	  language-specific methods. All objects that are the
	  <em>same</em> will also be <em>equal</em>, though the
	  reverse may not be true.For example, in C++ the <code>==</code> operator could be
	  bound to test for <em>sameness</em>. So if two objects
	  were equivalent in terms of <code>==</code> they would also
	  be equivalent in terms of this method, but even if the
	  objects compared true using this method, they may compare
	  differently in terms of the <code>==</code> operator.</i><br>
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>arg</b><td><td>
<p>The node to compare equality with.</td></tr>
<tr><td valign='top'><b>deep</b><td><td>
<p>A flag indicating whether the entire subtree below
	    the object should also be checked for equality. Is this is
	    <code>true</code> and the return value is
	    <code>true</code>, the two subtree should be considered
	    equivalent.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>If the nodes, and possibly subtrees are equivalent,
	  <code>true</code> otherwise <code>false</code>.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>
</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-536297177'>NodeList</a></i></b></dt>
<dd>
<p>The <code>NodeList</code> interface provides the abstraction of an
      ordered collection of nodes, without defining or
      constraining how this collection is implemented, allowing
      different DOM implementations to be tuned for their specific
      environments.<p>The items in the <code>NodeList</code> are accessible via an
      integral index, starting from 0.
    
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface NodeList {
  Node                      item(in unsigned long index);
  readonly attribute  unsigned long        size;
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Methods</b></dt>
<dd>

<dl>
<dt><code class='method-name'><b><i><a name='ID-844377136'></a><a name='method-item'>item</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Returns the <code>index</code>th item in the collection.
	If <code>index</code> is greater than or equal to the number
	of nodes in the list, NULL is returned.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>index</b><td><td>
<p>Index into the collection</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The node at the <code>index</code> position in the
	  <code>NodeList</code>, or <code>null</code> if that is not a
	  valid index.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>
</dd>
</dl>

<dl>
<dt><b>Attributes</b></dt>
<dd>

<dl>
<dt><code class='attribute-name'><b><i><a name='ID-203510337'></a><a name='attribute-size'>size</a></i></b></code></dt>
<dd>
<p>The number of nodes in the <code>NodeList</code> instance.
	The range of valid child node indices is 0 to
	<code>size-1</code> inclusive. </dd>
</dl>

</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-1780488922'>NamedNodeMap</a></i></b></dt>
<dd>
<p>Objects implementing the <code>NamedNodeMap</code>
      interface are used to represent collections of nodes that can be
      accessed by name. Objects contained in an object implementing
      <code>NamedNodeMap</code> may also be accessed by 
      ordinal index. The ability to access members of a
   NamedNodeMap by ordinal index does not imply that the DOM specifies an 
   order to these Nodes. These methods may simply be used for enumerating 
   all of members of the NamedNodeMap. 
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface NamedNodeMap {
  Node                      getNamedItem(in wstring name);
  void                      setNamedItem(in Node arg);
  Node                      removeNamedItem(in wstring name);
  Node                      item(in unsigned long index);
  readonly attribute  unsigned long        size;
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Methods</b></dt>
<dd>

<dl>
<dt><code class='method-name'><b><i><a name='ID-1074577549'></a><a name='method-getNamedItem'>getNamedItem</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Retrieves a node from a list by name
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>name</b><td><td>
<p>Name of a node to retrieve.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>A <code>Node</code> (of any type) with the specified
	  name, or <code>null</code> if the specified name did not
	  identify any node in the list. </dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-1025163788'></a><a name='method-setNamedItem'>setNamedItem</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Add a node to a <code>NamedNodeMap</code> using the
	<code>nodeName</code> attribute of the node.<i><b>Note: </b>As the <code>nodeName</code> attribute is used to
	derive the named which the node must be stored under, multiple
	nodes of certain types (those that have a "special" string
	value) cannot be stored as the names will clash. This is seen
	as preferable to allowing nodes to be aliased.</i><br>
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>arg</b><td><td>
<p>A node to store in a named node list. The node will
	later be accessible using the value of the
	<code>nodeName</code> attribute of the node.</td></tr>
</table>
</dd>
</dl>
<p><br>
This method returns nothing.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-D58B193'></a><a name='method-removeNamedItem'>removeNamedItem</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Remove a node identified by its name.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>name</b><td><td>
<p>The name of a node to remove</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The node removed from the list or <code>null</code>
	    if no node with such a name exists.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-349467F9'></a><a name='method-item'>item</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Returns the <code>index</code>th item in the collection.
	If <code>index</code> is greater than or equal to the number
	of nodes in the list, <code>null</code> is returned.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>index</b><td><td>
<p>Index into the collection</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The node at the <code>index</code> position in the
	  <code>NamedNodeMap</code>, or <code>null</code> if that is not a
	  valid index.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>
</dd>
</dl>

<dl>
<dt><b>Attributes</b></dt>
<dd>

<dl>
<dt><code class='attribute-name'><b><i><a name='ID-6D0FB19E'></a><a name='attribute-size'>size</a></i></b></code></dt>
<dd>
<p>The number of nodes in the <code>NamedNodeMap</code> instance.
	The range of valid child node indices is 0 to
	<code>size-1</code> inclusive. </dd>
</dl>

</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-FF21A306'>Data</a></i></b></dt>
<dd>
<p>The <code>Data</code> interface extends <code>Node</code>
      with a set of attributes and methods for accessing character
      data in the DOM. The set of interfaces is defined here rather
      than on each object that uses these interfaces for clarity. No
      DOM objects correspond directly to <code>Data</code>, though
      <code>Text</code> and others do inherit the interfaces from 
      it.
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface Data : Node {
           attribute  wstring              data;
  readonly attribute  unsigned long        size;
  wstring                   substring(in unsigned long start, 
                                      in unsigned long count)
                                      raises(DOMException);
  void                      append(in wstring arg);
  void                      insert(in unsigned long offset, 
                                   in wstring arg)
                                   raises(DOMException);
  void                      delete(in unsigned long offset, 
                                   in unsigned long count)
                                   raises(DOMException);
  void                      replace(in unsigned long offset, 
                                    in unsigned long count, 
                                    in wstring arg)
                                    raises(DOMException);
};

</pre>
</dd>
</dl>
<i><b>Note: </b>Since Data is a general name, and this interface is designed
   for Character Data (text), the name of this interface may change. 
   Some method and attribute names may also change to avoid confusion. </i><br>
<dl>
<dt><b>Attributes</b></dt>
<dd>

<dl>
<dt><code class='attribute-name'><b><i><a name='ID-72AB8359'></a><a name='attribute-data'>data</a></i></b></code></dt>
<dd>
<p>This provides access to the character data of a node
	that implements these interfaces. If the character data of
	node cannot fit into the length of a <code>wstring</code> a
	<code>DOMException</code> is raised. If this exception is
	detected, the user may call <code>substring</code> to retrieve
	the data in manageable chunks.</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-7D61178C'></a><a name='attribute-size'>size</a></i></b></code></dt>
<dd>
<p>This provides access to the number of characters that
    are available through <code>data</code> and the
    <code>substring</code> method below.  This may have the value zero, 
    i.e., Data nodes may be empty.</dd>
</dl>

</dd>
</dl>

<dl>
<dt><b>Methods</b></dt>
<dd>

<dl>
<dt><code class='method-name'><b><i><a name='ID-6531BCCF'></a><a name='method-substring'>substring</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Extracts a range of the data from this object
	implementing these interfaces.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>start</b><td><td>
<p>Start offset of substring to extract</td></tr>
<tr><td valign='top'><b>count</b><td><td>
<p>The number of characters to extract.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>This method returns the specified substring.</dd>
</dl>

<dl>
<dt><b>Exceptions</b></dt>
<dd>
<dl><dt><b>DOMException</b><dt><dd><p>Thrown if the specified range of text will not fit
	    into a <code>wstring</code>.</dd></dl>
</dd>
</dl>
<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-32791A2F'></a><a name='method-append'>append</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Append the string to the end of the character data in the
	object implementing these interfaces. Upon success,
	<code>data</code> will provide access to the concatenation of
	<code>data</code> and the <code>wstring</code> specified.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>arg</b><td><td>
<p>The <code>wstring</code> to append.</td></tr>
</table>
</dd>
</dl>
<p><br>
This method returns nothing.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-3EDB695F'></a><a name='method-insert'>insert</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Insert a string at the specified character offset.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>offset</b><td><td>
<p>The character offset at which to insert</td></tr>
<tr><td valign='top'><b>arg</b><td><td>
<p>The <code>wstring</code> to insert</td></tr>
</table>
</dd>
</dl>
<p>
<dl>
<dt><b>Exceptions</b></dt>
<dd>
<dl><dt><b>DOMException</b><dt><dd><p>Thrown if the specified offset is greater than the
	    number of characters in <code>data</code>.</dd></dl>
</dd>
</dl>
<br>
This method returns nothing.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-7C603781'></a><a name='method-delete'>delete</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Remove a range of characters from the node. Upon success,
	<code>data</code> and <code>size</code> will reflect the
	  change.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>offset</b><td><td>
<p>The offset from which to remove characters.</td></tr>
<tr><td valign='top'><b>count</b><td><td>
<p>The number of characters to delete. If the sum of
	<code>offset</code> and <code>count</code> exceeds
	<code>size</code> then all characters from <code>offset</code>
	to the end of the data are deleted.</td></tr>
</table>
</dd>
</dl>
<p>
<dl>
<dt><b>Exceptions</b></dt>
<dd>
<dl><dt><b>DOMException</b><dt><dd><p>Thrown if the specified offset is greater than the
	    number of characters in <code>data</code>.</dd></dl>
</dd>
</dl>
<br>
This method returns nothing.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-E5CBA7FB'></a><a name='method-replace'>replace</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Replace the characters starting at the specified character
	offset with the specified string.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>offset</b><td><td>
<p>The offset from which to start replacing.</td></tr>
<tr><td valign='top'><b>count</b><td><td>
<p>The number of characters to replace. If the sum of
	    <code>offset</code> and <code>count</code> exceeds
	    <code>size</code>, then all characters to the end of the data
	    are replaced (i.e. the effect is the same as a
	    <code>remove</code> method call with the same range, followed
	    by an <code>append</code> method invocation).</td></tr>
<tr><td valign='top'><b>arg</b><td><td>
<p>The <code>wstring</code> with which the range will
	    be replaced.</td></tr>
</table>
</dd>
</dl>
<p>
<dl>
<dt><b>Exceptions</b></dt>
<dd>
<dl><dt><b>DOMException</b><dt><dd><p>Thrown if the specified offset is greater than the
	    number of characters in <code>data</code>.</dd></dl>
</dd>
</dl>
<br>
This method returns nothing.<br>
</div>

</dd>
</dl>
</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-637646024'>Attribute</a></i></b></dt>
<dd>
<p>The <code>Attribute</code> interface represents an
      attribute in an <code>Element</code> object.  Typically the
      allowable values for the attribute are defined in a document
      type definition.
    <p>The attribute's effective value is determined as follows: if
      this attribute has been explicitly assigned any value, that
      value is the attribute's effective value; otherwise, if there is
      a declaration for this attribute, and that declaration includes
      a default value, then that default value is the attribute's
      effective value; otherwise, the attribute has no effective
      value. Note, in particular, that an effective value of the
      <code>null</code> string would be returned as a
      <code>Text</code> node instance whose <code>data</code>
      attribute will contain a zero length string. 
      If the attribute has no effective value,
      then this method will return <code>null</code>. Note the
      <code>value</code> attribute on the <code>Attribute</code>
      instance can also be used to retrieve the string version of the
      attribute's value(s). <font color='red'>(<i><b>ED: </b>We should probably have a table here
      showing how the combination of the attribute value and specified
      suffice to also determine if an attribute was defaulted.)</i></font><br>
<p>The <code>Attribute</code> inherits the <code>Node</code>
      interface, which has a <code>parentNode</code> attribute. This
      attribute is set to the <code>Element</code> associated with the
      attribute as an expedient way of getting from the attribute to
      the <code>Element</code>. <i><b>Note: </b>In XML, the value of an attribute is represented by the
	child nodes of an attribute node, since the value can be
	contain entity references. Thus, attributes which contain
	entity references will have a child list containing both text
	nodes and entity reference nodes. In addition, tokenised
	attribute types, such as <code>NMTOKENS</code> will result in
	a child list where each child represents a single token from
	the attribute value.</i><br>
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface Attribute : Node {
  wstring                   getName();
           attribute  boolean              specified;
  wstring                   getValue();
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Methods</b></dt>
<dd>

<dl>
<dt><code class='method-name'><b><i><a name='ID-1112119403'></a><a name='method-getName'>getName</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Returns the name of this attribute. <font color='red'>(<i><b>ED: </b>Given that we have nodeName on node, is
    this necessary? Also, even if we leave it in, it should probably
    be a readonly attribute.)</i></font><br>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<font color='red'>(<i><b>ED: </b>TBD.)</i></font><br>
</dd>
</dl>
<br>
This method has no parameters.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>
</dd>
</dl>

<dl>
<dt><b>Attributes</b></dt>
<dd>

<dl>
<dt><code class='attribute-name'><b><i><a name='ID-862529273'></a><a name='attribute-specified'>specified</a></i></b></code></dt>
<dd>
<p>If this attribute was explicitly given a value in the
	original document, this will be true; otherwise, it will be
	false.</dd>
</dl>

</dd>
</dl>

<dl>
<dt><b>Methods</b></dt>
<dd>

<dl>
<dt><code class='method-name'><b><i><a name='ID-221662474'></a><a name='method-getValue'>getValue</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Returns the value of the attribute as a string.
	Character and general entity references will have been
	replaced with their values in the returned string.
      
<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The value of the attribute as a <code>wstring</code>. <font color='red'>(<i><b>ED: </b>Given that we have nodeValue on node, is
	    this necessary? Also, even if we leave it in, it should probably
	    be an attribute.)</i></font><br>
</dd>
</dl>
<br>
This method has no parameters.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>
</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-745549614'>Element</a></i></b></dt>
<dd>
<p>By far the vast majority (apart from text) of node types
      that authors will encounter when traversing a document
      will be Element nodes.  These objects represent both the element
      itself, as well as any contained nodes. For example (in XML):
<blockquote>
<pre class='code-block'>&lt;elementExample id="demo"&gt;
  &lt;subelement1/&gt;
  &lt;subelement2&gt;&lt;subsubelement/&gt;&lt;/subelement2&gt;
&lt;/elementExample&gt;  </pre>
</blockquote>

    <p>When represented using DOM, the top node would be 
      "elementExample", which contains two child Element
      nodes (and some space), one for "subelement1" and one
      for "subelement2". "subelement1" contains no
      child nodes of its own.
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface Element : Node {
  wstring                   getTagName();
  NamedNodeMap              getAttributes();
  wstring                   getAttribute(in wstring name);
  void                      setAttribute(in string name, 
                                         in string value);
  void                      removeAttribute(in wstring name);
  Attribute                 getAttributeNode(in wstring name);
  void                      setAttributeNode(in Attribute newAttr);
  void                      removeAttributeNode(in Attribute oldAttr);
  NodeList                  getElementsByTagName(in wstring tagname);
  void                      normalize();
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Methods</b></dt>
<dd>

<dl>
<dt><code class='method-name'><b><i><a name='ID-104682815'></a><a name='method-getTagName'>getTagName</a></i></b></code></dt>
<dd>
<div class='method'>
<p>This method returns the string that is the element's
	name. For  example, in:  
<blockquote>
<pre class='code-block'>&lt;elementExample id="demo"&gt; 
        ... 
&lt;/elementExample&gt; </pre>
</blockquote>

	This would have the value
	<code>"elementExample"</code>. Note that this is
	case-preserving, as are all of the operations of the DOM. <font color='red'>(<i><b>ED: </b>Need to add section about name case
	  etc. and a reference to it here. )</i></font><br>
<font color='red'>(<i><b>ED: </b>Could we choose a better name for nodeName?
	Should tagName be an attribute (possibly read-only)?)</i></font><br>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The element's tag name</dd>
</dl>
<br>
This method has no parameters.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-495959484'></a><a name='method-getAttributes'>getAttributes</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Returns the attributes for this element. In the
	<code>elementExample</code> example above, the attributes list
	would consist of the <code>id</code> attribute, as well as any
	attributes which were defined by the document type definition
	for this element which have default values. <font color='red'>(<i><b>ED: </b>Is this necessary given that we have
	  attributes() on node? Should this be an attribute
	  here?)</i></font><br>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>Attribute list</dd>
</dl>
<br>
This method has no parameters.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-666EE0F9'></a><a name='method-getAttribute'>getAttribute</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Retrieves an <code>Attribute</code> value by name.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>name</b><td><td>
<p>The name of the attribute to retrieve</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The <code>Attribute</code> value as a string, or the empty 
	string if that attribute does not have a specified or
	defaulted value.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-F68F082'></a><a name='method-setAttribute'>setAttribute</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Adds a new attribute/value pair. If an attribute with that
	name is already present in the element, its value is changed
	to be that of the value parameter. <font color='red'>(<i><b>ED: </b>Perhaps this should return the
	  Attribute so that when a value is being replaced, you can
	  still access it?)</i></font><br>

<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>name</b><td><td>
<p>Name of an attribute</td></tr>
<tr><td valign='top'><b>value</b><td><td>
<p>Value to set in string form</td></tr>
</table>
</dd>
</dl>
<p><br>
This method returns nothing.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-6D6AC0F9'></a><a name='method-removeAttribute'>removeAttribute</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Removes the specified attribute. <font color='red'>(<i><b>ED: </b>Perhaps this should return the
	  Attribute so that when an attribute is being removed, you can
	  still access it?)</i></font><br>

<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>name</b><td><td>
<p>The name of attribute to remove</td></tr>
</table>
</dd>
</dl>
<p><br>
This method returns nothing.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-217A91B8'></a><a name='method-getAttributeNode'>getAttributeNode</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Retrieves an attribute node by name.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>name</b><td><td>
<p>The name of the attribute to retrieve</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>The attribute node with the specified attribute
	  name</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-887236154'></a><a name='method-setAttributeNode'>setAttributeNode</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Adds a new attribute/value pair. If an attribute by that
	name is already present in the element, its value is changed
	to be that of the Attribute instance.<font color='red'>(<i><b>ED: </b>Perhaps this should return the
	  Attribute so that when an attribute is being removed, you can
	  still access it?)</i></font><br>

<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>newAttr</b><td><td>
<p>The attribute node to add to the attribute list
	  </td></tr>
</table>
</dd>
</dl>
<p><br>
This method returns nothing.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-D589198'></a><a name='method-removeAttributeNode'>removeAttributeNode</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Removes the specified  attribute/value pair.<font color='red'>(<i><b>ED: </b>Perhaps this should return the
	  Attribute so that when an attribute is being removed, you can
	  still access it?)</i></font><br>

<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>oldAttr</b><td><td>
<p>The attribute node to remove from attribute list</td></tr>
</table>
</dd>
</dl>
<p><br>
This method returns nothing.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-1938918D'></a><a name='method-getElementsByTagName'>getElementsByTagName</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Returns a list of all elements in the sub-tree of 
        this element with a given tag name.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>tagname</b><td><td>
<p>The name of the tag to match on, or the wildcard string "*"
	to return all elements.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>This method returns a list of element nodes that
	  have the specified tag name.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-162CF083'></a><a name='method-normalize'>normalize</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Puts all <code>Text</code> nodes in the sub-tree
	underneath this <code>Element</code> into a "normal" form
	where only markup (e.g., tags, comments, processing
	instructions, CDATA sections, and entity references
	separates <code>Text</code> nodes.  This can be useful to
        ensure that the DOM view of a document is identical to how
        it would look if saved and re-loaded, and is useful if
        operations (such as XPointer lookups) that depend on a 
        particular document tree structure must be allowed.<p><br>
This method has no parameters.<br>
This method returns nothing.<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>
</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-1312295772'>Text</a></i></b></dt>
<dd>
<p>The <code>text</code> interface represents the non-markup
      content of an <code>Element</code>. If there is no markup
      inside an element's content, the text will be contained in a
      single object implementing the <code>Text</code> interface that
      is the child of the element.  Any markup will parse into child
      elements that are siblings of the text nodes on either side of
      it, and whose content will be represented as text node children
      of the markup element.<p>When a document is first made 
      available to the DOM, there is only one Text node for each block of 
      text. Users may create adjacent Text nodes that represent the 
      contents of a given element without any intervening markup, but
      should be aware that there is no way to represent the separations
      between these nodes in XML or HTML, so they will not (in general)
      persist between DOM editing sessions.  The <code>normalize()</code>
      method on <code>Element</code> will merge any such adjacent Text
      objects into a single node for each block of text; this is 
      recommended before employing operations that depend on a particular
      document structure,  such as navigation with <code>XPointers.</code>
    
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface Text : Data {
  Text                      splitText(in unsigned long offset);
  Text                      joinText(in Text node1, 
                                     in Text node2);
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Methods</b></dt>
<dd>

<dl>
<dt><code class='method-name'><b><i><a name='ID-38853C1D'></a><a name='method-splitText'>splitText</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Breaks a text node into two text nodes at the specified
	offset, keeping both in the tree as siblings.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>offset</b><td><td>
<p>The offset at which to split.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>This method returns the new text node containing
	  all the content at and after the <code>offset</code> point.
	  The original node contains all the  content up to the
	  <code>offset</code> point.</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>

<dl>
<dt><code class='method-name'><b><i><a name='ID-302F75BD'></a><a name='method-joinText'>joinText</a></i></b></code></dt>
<dd>
<div class='method'>
<p>Joins the contents of two Text nodes into a single text
	node, with only one returned node left in the tree.
<dl>
<dt><b>Parameters</b></dt>
<dd>
<table border='0'>
<tr><td valign='top'><b>node1</b><td><td>
<p>The first Text node to join.</td></tr>
<tr><td valign='top'><b>node2</b><td><td>
<p>The second Text node to join.</td></tr>
</table>
</dd>
</dl>

<dl>
<dt><b>Return Values</b></dt>
<dd>
<p>This method returns a new text node containing the contents of
	  <code>node1</code> and <code>node2</code>. The input nodes are not
	  modified.<font color='red'>(<i><b>ED: </b>This is just a suggestion; the WG
	    has not decided on the actual semantics of what joinText
	    does to the original nodes.)</i></font><br>
</dd>
</dl>
<br>
This method raises no exceptions.<br>
</div>

</dd>
</dl>
</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-1728279322'>Comment</a></i></b></dt>
<dd>
<p>This represents the content of a comment, i.e. all the
      characters between the starting '<code>&lt;!--</code>' and
      ending '<code>--&gt;</code>'. Note that this is the definition
      of a comment in XML, and, in practice, HTML, although some HTML
      tools may implement the full SGML comment structure.
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface Comment : Data {
};

</pre>
</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-1004215813'>ProcessingInstruction</a></i></b></dt>
<dd>
<p>The <code>ProcessingInstruction</code> interface
      represents a  "processing instruction", used in XML
      (and legal, though seldom supported, in HTML) as a way to keep
      processor-specific information in the text of the document. The
      content of the node is the entire content between the delimiters
      of the processing instruction.
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface ProcessingInstruction : Node {
           attribute  wstring              target;
           attribute  wstring              data;
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Attributes</b></dt>
<dd>

<dl>
<dt><code class='attribute-name'><b><i><a name='ID-1478689192'></a><a name='attribute-target'>target</a></i></b></code></dt>
<dd>
<p>XML defines a target as the first token following the
	markup that begins the processing instruction, and this
	attribute returns that name. For HTML, the returned value
	is <code>null</code>. </dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-837822393'></a><a name='attribute-data'>data</a></i></b></code></dt>
<dd>
<p>The content of the processing instruction, from the
	character immediately after the <code>&lt;?</code> (after the
	target in XML) to the character immediately preceding the
	<code>?&gt;</code> (the <code>&gt;</code> in HTML).<font color='red'>(<i><b>ED: </b>How does this relate to the attribute
	on Node?)</i></font><br>
</dd>
</dl>

</dd>
</dl>
</dd>
</dl>

<br>
<a name='ID-E067D597'></a>
<h2 class='div2'>1.3. Extended Interfaces</h2><p>The interfaces defined here form part of the DOM Level 1 Core 
      specification, but objects that 
      expose these interfaces will never be encountered in a DOM implementation
      that deals only with HTML. As such, HTML-only DOM
      implementations do not need to have objects that implement these
      interfaces.</p>
<dl>
<dt><b>Interface <i><a name='ID-667469212'>CDATASection</a></i></b></dt>
<dd>
<p>CDATA sections are used in the document instance, and
      provide a region in which most of the XML delimiter recognition
      does not take  place. The primary purpose is for including
      material such as XML  fragments, without needing to escape all
      the delimiters.<p>The <code>wstring</code> attribute of the
      <code>Text</code> node holds the text that was contained by the CDATA
      section. Note that this <em>may</em> contain characters
      that need to be escaped outside of CDATA sections.
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface CDATASection : Text {
};

</pre>
</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-412266927'>DocumentType</a></i></b></dt>
<dd>
<p>Each document has a (possibly null) attribute that
      contains a reference to a <code>DocumentType</code> object. 
      The <code>DocumentType</code> class in the DOM Level 1 core
      provides an interface to the list of entities that are defined
      for the document, and little else because the effect of
      namespaces and the various XML scheme efforts on DTD
      representation are not yet clearly understood.
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface DocumentType : Node {
           attribute  wstring              name;
  readonly attribute  NamedNodeMap         entities;
  readonly attribute  NamedNodeMap         notations;
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Attributes</b></dt>
<dd>

<dl>
<dt><code class='attribute-name'><b><i><a name='ID-1844763134'></a><a name='attribute-name'>name</a></i></b></code></dt>
<dd>
<p>The <code>name</code> attribute is a <code>wstring</code> that
	holds the name of DTD; i.e. the name immediately
	following the <code>DOCTYPE</code> keyword.</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-1788794630'></a><a name='attribute-entities'>entities</a></i></b></code></dt>
<dd>
<p>This is a <code>NamedNodeMap</code> containing 
	the general entities, both external and internal, 
        declared in the DTD. For example in:
<blockquote>
<pre class='code-block'>&lt;!DOCTYPE ex SYSTEM "ex.dtd" [
  &lt;!ENTITY foo "foo"&gt;
  &lt;!ENTITY bar "bar"&gt;
  &lt;!ENTITY % baz "baz"&gt;
]&gt;
&lt;ex/&gt;</pre>
</blockquote>
  
	the interface would provide access to <code>foo</code> and
	<code>bar</code> but not <code>baz</code>. All objects supporting
	the <code>Node</code> interface that are accessed though this
	attribute, will also support the
	<code>Entity</code> interface. For HTML, this will always be
	<code>null</code>.</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-D46829EF'></a><a name='attribute-notations'>notations</a></i></b></code></dt>
<dd>
<p>This is a <code>NamedNodeMap</code> containing  the
	notations declared in the DTD. Each node in this map will also
	implement the <code>Notation</code> interface.</dd>
</dl>

</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-5431D1B9'>Notation</a></i></b></dt>
<dd>
<p>This interface represents a notation declared in the
    DTD. A notation declares, by name, the format of an unparsed
    entity (see section 4.7 of the XML 1.0 specification). The
    <code>nodeName</code> attribute inherited from <code>Node</code>
    is set to the declared name of the notation. 
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface Notation : Node {
           attribute  wstring              publicId;
           attribute  wstring              systemId;
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Attributes</b></dt>
<dd>

<dl>
<dt><code class='attribute-name'><b><i><a name='ID-54F2B4D0'></a><a name='attribute-publicId'>publicId</a></i></b></code></dt>
<dd>
<p>The public identifier for the notation. If the 
	public identifier was not specified, this is
	<code>null</code>.</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-E8AAB1D0'></a><a name='attribute-systemId'>systemId</a></i></b></code></dt>
<dd>
<p>The system identifier for the notation. If the 
	system identifier was not specified, this is
	<code>null</code>.</dd>
</dl>

</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-527DCFF2'>Entity</a></i></b></dt>
<dd>
<p>This interface represents an entity, either parsed or
      unparsed, in an XML document. Note that this models the entity
      itself <em>not</em> the entity declaration. Entity
      declaration modeling has been left for a later Level of the DOM
      specification.<p>The <code>nodeName</code> attribute that is inherited from
      <code>Node</code> contains the name of the entity.<p>The structure of the child list is exactly the same as
      the structure of the child list for an
      <code>EntityReference</code> with the same <code>nodeName</code>
      value. <font color='red'>(<i><b>ED: </b>Should we have something about resolution
	of entities? What happens if an entity was declared but not
	resolved? Should we have a method to force resolution?)</i></font><br>

<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface Entity : Node {
           attribute  wstring              publicId;
           attribute  wstring              systemId;
           attribute  wstring              notationName;
};

</pre>
</dd>
</dl>

<dl>
<dt><b>Attributes</b></dt>
<dd>

<dl>
<dt><code class='attribute-name'><b><i><a name='ID-D7303025'></a><a name='attribute-publicId'>publicId</a></i></b></code></dt>
<dd>
<p>The public identifier associated with the entity, if
	specified. If the public identifier was not specified, this
	is <code>null</code>.</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-D7C29F3E'></a><a name='attribute-systemId'>systemId</a></i></b></code></dt>
<dd>
<p>The system identifier associated with the entity, if
	specified. If the system identifier was not specified, this
	is <code>null</code>.</dd>
</dl>


<dl>
<dt><code class='attribute-name'><b><i><a name='ID-6ABAEB38'></a><a name='attribute-notationName'>notationName</a></i></b></code></dt>
<dd>
<p>For unparsed entities, the name of the notation for the
	entity. For parsed entities, this is <code>null</code>. <font color='red'>(<i><b>ED: </b>Perhaps there should be a predefined
	value for parsed entities other than null?)</i></font><br>
</dd>
</dl>

</dd>
</dl>
</dd>
</dl>


<dl>
<dt><b>Interface <i><a name='ID-11C98490'>EntityReference</a></i></b></dt>
<dd>
<p><code>EntityReference</code> objects are inserted into the
      DOM by the XML processor whenever the processor sees a reference
      to an entity other than the pre-defined character entities in the
      XML specification. The replacement value, if it is available,
      will appear in the child list of the <code>EntityReference</code>.<p>XML does not mandate that a non-validating XML processor read
      and process entity declarations  made in the external subset or
      declared in external parameter entities. This means
      that parsed entities declared in the external subset
      need not be expanded by some classes of applications, and that
      the replacement value of the entity may not be
      available. <i><b>Note: </b>There is a suggestion that the <code>nodeName</code> 
      attribute inherited from
      <code>Node</code> be set to the declared name of the
      entity. This could then be used to access the entity via the
      <code>NamedNodeMap</code> in the object implementing the
      <code>DocumentType</code> interfaces for a given
      document. Another suggestion is to add an <code>entityName</code>
      attribute instead, to avoid clashes with the nodeName of the Entity
      itself.</i><br>
<dl>
<dt><b>IDL Definition</b></dt>
<dd>
<pre class='idl-code'>
interface EntityReference : Node {
};

</pre>
</dd>
</dl>
</dd>
</dl>

<div class='noprint'>
<br><hr>
<table width='100%' cellpadding='0' class='navigation-bar'>
<tr>
<td width='30%' align='left'><a href='introduction.html'><img border='0' src='./back.jpg' alt=' What is the Document Object Model?'></a></td>
<td width='30%' align='center'><a href='cover.html'><img border='0' src='./up.jpg' alt='Cover'></a></td>
<td width='30%' align='right'><a href='level-one-html.html'><img border='0' src='./forward.jpg' alt=' Document Object Model (HTML) Level 1'></a></td>
</tr>
</table>
<hr>
</div>
</body>
</html>
